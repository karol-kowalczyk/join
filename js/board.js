/**
 * Asynchronous function that retrieves tasks from storage, processes them, and adds them to the todos list.
 * Each task comprises the following properties: id, category, task category, title, text, done fraction, members, priority, selected color, date, and task ID.
 * After the tasks are added, the HTML is updated to reflect the new tasks.
 * 
 * @async
 * @function
 * @returns {Promise<void>} No return value
 * @throws {Error} Throws an error if loading tasks or converting the resulting string to JSON fails.
 */
async function addTask() {
    let addTasks = JSON.parse(await getItem('task'));
    let popup = document.getElementById('addTaskPopup');
    let selectedCategory = popup.dataset.category || 'open';
    if (!addTasks || addTasks.length === 0) {
        return;
    }

    for (let taskArray of addTasks) {
        for (let task of taskArray) {
            let existingTask = todos.find(t => t.taskID === task.taskID);
            if (!existingTask) {
                let members = (task.persons && task.persons.length > 0) ? task.persons.map(person => person.name) : ['All Employees rgb(200, 200, 120)'];

                let subtasksWithCompletion = task.subtasks ? task.subtasks.map(subtask => ({ subtask, isComplete: false })) : [];

                todos.push({
                    'id': todos.length,
                    'category': task.status,
                    'task-category': task.category,
                    'title': task.title,
                    'text': task.description,
                    'done-fraction': '',
                    'members': members,
                    'priority': task.priority,
                    'subtasks': subtasksWithCompletion,
                    'date': task.date,
                    'taskID': task.taskID,
                    'task-color': task.color
                })
            }
        }
    }
    // setItemTodo();
    updateHTML();
}


/**
 * Asynchronous function that retrieves stored todos from the storage.
 * If stored todos exist, it parses the JSON string to an object and assigns it to the 'todos' array.
 *
 * @async
 * @function
 * @returns {Promise<void>} No return value.
 * @throws {Error} Throws an error if loading todos or parsing the resulting string fails.
 */
async function getStoredTodos() {
    const storedTodos = await getItem('todos');
    if (storedTodos) {
        todos = JSON.parse(storedTodos);
    }
}


/**
 * This function is used to initiate the HTML page.  
 * It will include the template for the header and navigation. 
 * In addition, the toDo divs are generated.
 */
async function initBoard() {
    await getStoredTodos();
    await addTask();
    init();
    initArrays();
    updateHTML();
}


/**
 * This function contains the subfunctions for rendering the four subboards: open, progress, feedback and closed.
 * In addition, the full name and the name abbreviation are generated by the corresponding function call.
 * Finally, the function for styling the todo divs is called.
 */
async function updateHTML() {
    renderToDos('open');
    renderToDos('progress');
    renderToDos('feedback');
    renderToDos('closed');
    styleTodos();
    await setItemTodo();
}


/**
 * Asynchronous function that stores the current state of 'todos' into storage.
 * It serializes the 'todos' array to a JSON string before storing.
 *
 * @async
 * @function
 * @returns {Promise<void>} No return value.
 * @throws {Error} Throws an error if setting the item in storage fails.
 */
async function setItemTodo() {
    //Clear task storage dont delete!!!
    // todos = [];
    // await setItem('task', JSON.stringify(todos));
    await setItem('todos', JSON.stringify(todos));
}


/**
 * This function is used to filter todos by category with subsequent generation of todo div elements.
 * 
 * @param {string} category - This parameter stands for the category of a todo and at the same time for the name of the subboard to which it belongs.
*/
function renderToDos(category) {
    document.getElementById(category + 'EmptyFrame').classList.add('display-none');

    let filteredToDos = todos.filter(t => t['category'] == category);
    const nextPosition = category + (filteredToDos.length - 1);

    document.getElementById(category).innerHTML = '';

    for (let i = 0; i < filteredToDos.length; i++) {
        const element = filteredToDos[i];
        document.getElementById(category).innerHTML += generateToDoHTML(element, category, i, nextPosition);
        generateToDoHTML(i);
    }
}


/**
 * This function is used to store the currently "dragged" todo div ID in a global variable.
 * 
 * @param {number} id - This is the number of the currently dragged todo div (= ID)
 */
function startDragging(id, cat) {
    currentDraggedElement = id;
    currentDraggedCategory = cat;
}


/**
 * This function allows the drop functionality. It is a standard of the w3 consortium.
 * 
 * @param {} ev - This parameter is mandatory for the w3 consortium drop function.
 */
function allowDrop(ev) {
    ev.preventDefault();
}


/**
 * This is the "drop functionality". The current todo div is assigned the corresponding new category of the subboard.
 * Subsequently, the todo divs are regenerated; that is, updated.
 * 
 * @param {string} category - This parameter is the name of the new category
 */
async function movedTo(category) {
    todos[currentDraggedElement]['category'] = category;
    updateHTML();
    await setItemTodo();
    hideEmptyFrame(category);
}


/**
 * This function hides the placeholder frame for a task.
 * 
 * @param {*} category - This value is the category associated with the task.
 */
function hideEmptyFrame(category) {
    document.getElementById(category + 'EmptyFrame').classList.add('display-none');
}


/**
 * This function adds style elements to the todo divs.
 */
function styleTodos() {
    for (let i = 0; i < todos.length; i++) {
        const selectedColor = todos[i]['selected-color'];
        // document.getElementById(`todoBoxHeader${todos[i]['id']}`).classList.add(`bg-cat-color-${selectedColor}`);
    }
}


/**
 * Retrieves the CSS variable representation of a specified color name.
 * 
 * @param {string} colorName - The name of the color for which the CSS variable should be retrieved.
 * @returns {string} - The CSS variable representation of the color. Returns 'var(--lightblue)' as a fallback if the color name is not recognized.
 * 
 * @example
 * // Assuming CSS variables are set like: --lightblue: #ADD8E6;
 * const cssVar = getColorVariable('lightblue'); // returns 'var(--lightblue)'
 */
function getColorVariable(colorName) {
    switch (colorName) {
        case 'lightblue': return 'var(--lightblue)';
        case 'red': return 'var(--red)';
        case 'green': return 'var(--green)';
        case 'orange': return 'var(--orange)';
        case 'purple': return 'var(--purple)';
        case 'darkblue': return 'var(--darkblue)';
        case 'mint': return 'var(--mint)';
        case 'pink': return 'var(--pink)';
        default: return 'var(--lightblue)'; // Fallback-Wert
    }
}


/**
 * Extracts the first two letters from a given string and converts them to uppercase.
 *
 * @param {string} member - The string from which to extract the first two letters.
 * @returns {string} The first two letters of the input string in uppercase, or undefined if input is not a string.
 */
function getFirstTwoLetters(members) {
    let letterDivs = '';

    if (Array.isArray(members)) {
        for (let i = 0; i < Math.min(members.length, 2); i++) {
            let member = members[i];
            let splitMember = member.split(' rgb(');
            let name = splitMember[0];
            let color = splitMember[1].replace(')', '');

            if (name) {
                let firstTwoLetters = name.slice(0, 2).toUpperCase();
                letterDivs += `<div class="todo-icon-name" style="background-color:rgb(${color});">${firstTwoLetters}</div>`;
            }
        }
        if (members.length > 2) {
            let defaultColor = '#000000';
            letterDivs += `<div class="todo-icon-name" style="background-color:${defaultColor};">+${members.length - 2}</div>`;
        }
    }

    return letterDivs;
}


/**
 * Filters the global `todos` array based on a search string and updates the HTML of the corresponding category
 * for each matched todo item.
 */
function searchTodos() {
    let searchString = document.getElementById('searchInput').value.toLowerCase();
    let searchedTodos = todos.filter(todo =>
        todo.title.toLowerCase().includes(searchString) ||
        todo.text.toLowerCase().includes(searchString));
    ['open', 'progress', 'feedback', 'closed'].forEach(category =>
        document.getElementById(category).innerHTML = ''
    );
    for (let todo of searchedTodos) {
        document.getElementById(todo.category).innerHTML += generateToDoHTML(todo);
    }
}


/**
 * Displays the "Add Task" popup with a specific color and assigns a category to it.
 * 
 * @param {string} color - The background color to be applied to the popup after an animation delay.
 * @param {string} category - The category to be associated with the popup task.
 * 
 * @example
 * showAddTaskPopup('#FF5733', 'work'); // Sets the popup background color to '#FF5733' and associates it with the 'work' category.
 */
function showAddTaskPopup(color, category) {
    selectedCategory = category;
    let popup = document.getElementById('addTaskPopup');
    let popupContainer = document.getElementById('addTaskPopupContainer');
    popup.dataset.category = category;
    popup.classList.toggle('popupAnimation');
    
    setTimeout(() => {
        popup.style.backgroundColor = `${color}`;
        popup.style.opacity = '1';
        popupContainer.style.opacity = '1';
    }, 125);
    updateHTML();
}


/**
 * Moves the category of the specified todo element one step up in the predefined category order.
 * If the todo is already in the topmost category, no changes will be made.
 *
 * @param {number} elementId - The ID of the todo element to be moved up in category.
 */
function upCategory(elementId) {
    let todo = todos[elementId];

    let currentCategoryIndex = categoriesOrder.indexOf(todo.category);
    if (currentCategoryIndex > 0) {
        todo.category = categoriesOrder[currentCategoryIndex - 1];
        updateHTML();
    }
}


/**
 * Moves the category of the specified todo element one step down in the predefined category order.
 * If the todo is already in the bottommost category, no changes will be made.
 *
 * @param {number} elementId - The ID of the todo element to be moved down in category.
 */
function downCategory(elementId) {
    let todo = todos[elementId];

    let currentCategoryIndex = categoriesOrder.indexOf(todo.category);
    if (currentCategoryIndex < categoriesOrder.length - 1) {
        todo.category = categoriesOrder[currentCategoryIndex + 1];
        updateHTML();
    }
}

/**
 * This function provides the hover effect when the tasks are dragged over a category.
 * 
 * @param {*} currentCat - This value determines the category over which a task is dragged.
 */
function highlight(currentCat) {
    let empty = document.getElementById(currentCat).innerHTML;
    if (currentDraggedCategory !== currentCat) {
        if (!empty == "") {
            let nextPlaceId = document.getElementById(currentCat + '0').innerHTML;
            document.getElementById(nextPlaceId).classList.remove('display-none');
        }
        if (empty == "") {
            document.getElementById(currentCat + 'EmptyFrame').classList.remove('display-none');
        }
    }
}
